<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>「UMLモデリングの本質」を読んだ</title>
    <meta property="og:title" content="「UMLモデリングの本質」を読んだ">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://blog.naoty.dev/253/">
    <meta property="og:image" content="https://blog.naoty.dev/253/http://ecx.images-amazon.com/images/I/41LkPJiQcNL._SL160_.jpg">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@naoty_k">
    <link href="/normalize.css" rel="stylesheet">
    <link href="/main.css" rel="stylesheet">
    <link href="/highlight.css" rel="stylesheet">
    <link href="/favicon.png" rel="shortcut icon" type="image/png">
    <link href="/feed.xml" rel="alternate" type="application/atom+xml">
  </head>
  <body>
    <main>
      <article>
        <header>
          <h1 class="title mt-0">「UMLモデリングの本質」を読んだ</h1>
          <p class="metadata">
            <time datetime="2015-02-28T11:25:00.000+0000">2015-02-28 11:25</time>
            <a href="/book/">#book</a>
          </p>
        </header>
        <section class="body">
          <p><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4822284646/naotoknk-22/"><img src="http://ecx.images-amazon.com/images/I/41LkPJiQcNL._SL160_.jpg" alt="UMLモデリングの本質 第2版" title="UMLモデリングの本質 第2版"></a></p>
<p><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4822284646/naotoknk-22/">UMLモデリングの本質 第2版</a></p>
<ul>
<li>作者: 児玉公信</li>
<li>出版社/メーカー: 日経BP社</li>
<li>発売日: 2011/05/26</li>
<li>メディア: 単行本</li>
<li>購入: 6人 クリック: 23回</li>
<li><a href="http://d.hatena.ne.jp/asin/4822284646/naotoknk-22">この商品を含むブログ (6件) を見る</a></li>
</ul>
<p>「UMLモデリングの本質」という本を読んだ。最近、ソフトウェアの設計について興味があって、いろいろ調べてみたところ各所でこの本がオススメされていたので手にとってみた。以前のエントリー（<a href="http://naoty.hatenablog.com/entry/2015/02/02/012733">「達人に学ぶDB設計徹底指南書」を読んだ - naoty.to_s</a>）でデータベースの設計について理解できたんだけど、結局のところ、そのシステムが扱う業務内容をいかにして実装可能なモデルに落とし込むか（=モデリング）が重要になってくると思う。この本で理解したかったのはそこだった。タイトルからUMLの書き方についての本のようにも思えるが、そうではなく、むしろまったくUMLの書き方は書いてない。UMLを使って、複雑な業務用件をいかにモデリングするかを説いている。本書は300ページに満たないものの、密度が非常にあり2, 3週間でゆっくり読んでも第3章までしか読めていない。それでも、十分に学びがあったので忘れてしまう前にエントリーとして残しておきたいと思う。</p>
<h1>モデリングとは</h1>
<p>モデリングとは「仕組みや概念を理解するために概念的な要素とそれらの関係を記述すること」とあった。これは普段の業務で多かれ少なかれ必ず行っていると思う。ただ、それをモデリングという工程として認識してはいなかった。そして、モデリングの手法についても特に考えることはなかった。いつも漫然とノートに四角形と線を書いて整理してた（以下、イメージ）。</p>
<p><img src="http://cdn-ak.f.st-hatena.com/images/fotolife/n/naoty_k/20150228/20150228013509.jpg" alt="f:id:naoty_k:20150228013509j:plain:h400" title="f:id:naoty_k:20150228013509j:plain:h400"></p>
<p>こういう自己流ではなくて、標準的な概念の表記法がある。その1つがUMLだ。UMLを習得することで、他人とのコミュニケーションの手段として使えるようになるし、UMLを通して標準的なモデリングの手法も学べるようになる。</p>
<p>本書によると、モデリングは大まかに以下の順番に行っていくようだ。</p>
<ol>
<li>業務フロー図を書いて業務フローを整理する。</li>
<li>業務フローからユースケース図を書いてユースケースを洗い出す。</li>
<li>ユースケースから概念となる名詞を抜き出し、初期の型図を作成する。型図というのは実際はクラス図のことで、クラスと言っちゃうとクラスとして実装されることを含意してしまうが、実際にはクラスとは限らないため型図という言い方をしている。</li>
<li>ユースケースごとにシーケンス図を書く。これによって各アクターの責務が明確になり、初期の型図を機能的側面から修正することができる。</li>
</ol>
<p>UMLはけっこうな種類があるような気がするけど、とりあえず上に出てきた図だけ覚えておけばよさそうだ。各ステップの具体的な方法については本書を参照してほしい。読んだだけではあまり意味がないと思うので、近いうちに簡単な例で実践してみたいと思っている。</p>
<h1>分類の実装</h1>
<p>モデリングの手法の次はより実装に近い話が続く。その中でも分類の実装の話がよかった。例えば、ユーザーに「有料会員」と「無料会員」という分類がある場合に、それをフラグとして実装するのか「Stateクラス」として実装するのかという議論がある。</p>
<pre><code># フラグで実装

class User &lt; ActiveRecord::Base
  enum plan: %i(free premium)
end
</code></pre>
<pre><code># Stateクラスで実装

class User &lt; ActiveRecord::Base
  has_one :plan
end

class Plan &lt; ActiveRecord::Base
end

class Free &lt; Plan
end

class Premium &lt; Plan
end
</code></pre>
<p>個人的にはStateクラスという手法を知らなかったので、いつも前者のフラグとして実装していた。この実装の問題点は、状態が増えた場合にコードを修正する必要がある点と、if文の分岐を多用することになりコードが複雑になってしまう点がある。特に後者は、状態フラグの種類（例えば、「公開アカウント」or「非公開アカウント」）が増えたときに組み合わせが倍になり指数関数的に複雑になってしまうため、重大な問題点だと思う。</p>
<p>Stateクラスであれば、サブクラスを追加するだけでよく既存のコードを修正する必要がない。if文による分岐もダックタイピングによって解決する。状態フラグが複数になった場合は、直交する状態をサブクラスとして定義する（<code>PublicFree</code>, <code>PrivatePremium</code>など）のがよいと本書では書かれていた。状態によって振る舞いが異なる場合や状態が増える可能性がある場合は、フラグではなくStateクラスで実装する方がいいのかもしれない。</p>
<h1>ファサード</h1>
<p>モデリングによって整理された概念をクラスとして実装する際、層別化アーキテクチャを使うのがいいという話が出てくる。よく知られた4層モデルの話で、システムを「ユーザーインターフェイス層」「アプリケーション層」「ドメイン層」「永続層」に分離し、層間の参照を一方向にすることで結合度を抑えるというアプローチだ。このとき、モデリングによって整理された概念はそのままドメイン層に配置することになる。そして、アプリケーション層には業務フローで定義された手続きや処理の手順を定義していくことになる。</p>
<p>アプリケーション層を実装していくなかで、ドメイン層に定義された概念が高度に抽象化されていて扱いづらいときがある。とは言え、これまでのモデリングで練り上げてきた概念をアプリケーション層の都合でねじまげるわけにはいかないだろう。そこで登場するのがファサードというオブジェクトだ。ファサードはアプリケーション層からは冗長に見えるドメインを1つにまとめて扱いやすくする。さらに、複数のドメインにまたがった排他制御も扱う。</p>
<p>ファサードという概念はなんとなく耳にしたことがあったが、モデリング→実装という流れの文脈で捉えるとその必要性を実感することができた。普段RailsでMVCだけを書いていると、こうした視点が持てずにドメインをねじ曲げてしまうことがある。なので、ファサードの実装方法について調べて実践していきたいと思った。</p>
        </section>
        <footer>
          <nav>
            <ul class="footer-links mb-0">
              <li class="footer-link"><a href="https://naoty.dev">Home</a></li>
              <li class="footer-link"><a href="/">Posts</a></li>
            </ul>
          </nav>
        </footer>
      </article>
    </main>
  </body>
</html>
